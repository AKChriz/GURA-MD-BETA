const { downloadMediaMessage } = require('@whiskeysockets/baileys');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const sharp = require('sharp');
const he = require("he"); 
const image2url = require("image2url");

const enhancedCommands = {
    tourl: {
        description: 'Upload image to get URL',
        usage: 'tourl (reply to image)',
        adminOnly: false,
        execute: async (context) => {
            const { chatId, bot, message } = context;

            let targetMessage = null;

            // Check if replying to an image
            const quotedMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;
            if (quotedMessage?.imageMessage) {
                targetMessage = {
                    key: message.message.extendedTextMessage.contextInfo.stanzaId,
                    message: quotedMessage
                };
            }
            // Or if current message is an image
            else if (message.message?.imageMessage) {
                targetMessage = message;
            }

            if (!targetMessage) {
                await bot.sendMessage(chatId, { text: '‚ùå Please reply to an image or send an image with the command.' });
                return;
            }

            try {
                await bot.sendMessage(chatId, { text: '‚è≥ Uploading image...' });

                // Download image as buffer
                const buffer = await downloadMediaMessage(targetMessage, 'buffer', {});
                if (!buffer) {
                    await bot.sendMessage(chatId, { text: '‚ùå Failed to download image.' });
                    return;
                }

                // Save buffer to temp file
                const tempDir = path.join(__dirname, "..", "temp");
                if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir, { recursive: true });

                const tempFile = path.join(tempDir, `upload_${Date.now()}.jpg`);
                fs.writeFileSync(tempFile, buffer);

                // Upload with image2url
                const imgbbKey = process.env.IMG_BB_KEY; // API key
                const uploadedUrl = await image2url.imgbb_upload(tempFile, imgbbKey);

                await bot.sendMessage(chatId, {
                    text: `‚úÖ *Image uploaded successfully!*\n\nüìé URL: ${uploadedUrl}`
                });

                // Cleanup temp file
                fs.unlinkSync(tempFile);

            } catch (error) {
                console.error("‚ùå Upload error:", error);
                await bot.sendMessage(chatId, { text: '‚ùå Error uploading image to server.' });
            }
        }
    },



    movie: {
        description: 'Get movie information',
        usage: 'movie <movie name>',
        adminOnly: false,
        execute: async (context) => {
            const { args, chatId, bot } = context;
            
            if (args.length === 0) {
                await bot.sendMessage(chatId, '‚ùå Please provide a movie name.\nUsage: !movie Avengers');
                return;
            }
            
            try {
                const movieName = args.join(' ');
                const response = await axios.get(`http://www.omdbapi.com/?t=${encodeURIComponent(movieName)}&apikey=4428164a`);
                const movie = response.data;
                
                if (movie.Response === 'False') {
                    await bot.sendMessage(chatId, '‚ùå Movie not found. Please check the spelling and try again.');
                    return;
                }
                
                const movieText = `üé¨ *${movie.Title}* (${movie.Year})\n\n` +
                    `‚≠ê Rating: ${movie.imdbRating}/10\n` +
                    `üé≠ Genre: ${movie.Genre}\n` +
                    `üé¨ Director: ${movie.Director}\n` +
                    `üé≠ Cast: ${movie.Actors}\n` +
                    `‚è±Ô∏è Runtime: ${movie.Runtime}\n` +
                    `üèÜ Awards: ${movie.Awards}\n\n` +
                    `üìù *Plot:*\n${movie.Plot}`;
                
                await bot.sendMessage(chatId, movieText);
            } catch (error) {
                await bot.sendMessage(chatId, '‚ùå Error fetching movie information. Try again later!');
            }
        }
    },

    anime: {
        description: 'Get anime information',
        usage: 'anime <anime name>',
        aliases: ["ani"],
        adminOnly: false,
        execute: async (context) => {
            const { args, chatId, bot } = context;

            if (!args.length) {
                await bot.sendMessage(chatId, { text: '‚ùå Please provide an anime name.\nUsage: !anime Naruto' });
                return;
            }

            try {
                const animeName = args.join(' ');

                const query = `
                    query ($search: String) {
                        Media (search: $search, type: ANIME) {
                            title { romaji english }
                            description
                            episodes
                            status
                            averageScore
                            genres
                            format
                            startDate { year }
                            endDate { year }
                            coverImage { large medium }
                            siteUrl
                        }
                    }
                `;

                const response = await axios.post('https://graphql.anilist.co', {
                    query: query,
                    variables: { search: animeName }
                });

                const anime = response.data.data.Media;

                if (!anime) {
                    await bot.sendMessage(chatId, { text: '‚ùå Anime not found. Check spelling and try again.' });
                    return;
                }

                const title = anime.title.english || anime.title.romaji;
                const description = anime.description ? anime.description.replace(/<[^>]*>/g, '') : 'No description available';
                const truncatedDesc = description.length > 300 ? description.substring(0, 300) + '...' : description;
                const imageUrl = anime.coverImage?.large || anime.coverImage?.medium || null;

                let animeText =
                    `üéå *${title}*\n\n` +
                    `‚≠ê Score: ${anime.averageScore ? anime.averageScore + '/100' : 'N/A'}\n` +
                    `üì∫ Episodes: ${anime.episodes || 'Unknown'}\n` +
                    `üìÖ Year: ${anime.startDate?.year || 'Unknown'}\n` +
                    `üì∫ Format: ${anime.format || 'Unknown'}\n` +
                    `üìä Status: ${anime.status || 'Unknown'}\n` +
                    `üè∑Ô∏è Genres: ${anime.genres ? anime.genres.join(', ') : 'Unknown'}\n\n` +
                    `üìù *Description:*\n${truncatedDesc}\n\n` +
                    `üîó [AniList Link](${anime.siteUrl})`;

                if (animeText.length > 1000) {
                    animeText = animeText.substring(0, 950) + '...';
                }

                if (imageUrl) {
                    const imageBuffer = (await axios.get(imageUrl, { responseType: 'arraybuffer' })).data;
                    await bot.sendMessage(chatId, { image: imageBuffer, caption: animeText });
                } else {
                    await bot.sendMessage(chatId, { text: animeText });
                }

            } catch (err) {
                console.error('‚ùå Anime command error:', err);
                await bot.sendMessage(chatId, { text: '‚ùå Error fetching anime information. Try again later!' });
            }
        }
    },



    toimg: {
        description: 'Convert sticker to image',
        usage: 'toimg (reply to sticker)',
        adminOnly: false,
        execute: async (context) => {
            const { chatId, bot, message } = context;
            
            const quotedMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;
            if (!quotedMessage?.stickerMessage) {
                await bot.sendMessage(chatId, '‚ùå Please reply to a sticker.');
                return;
            }
            
            try {
                await bot.sendMessage(chatId, '‚è≥ Converting sticker to image...');
                
                const fakeMessage = {
                    key: message.message.extendedTextMessage.contextInfo.stanzaId,
                    message: quotedMessage
                };
                
                const buffer = await downloadMediaMessage(fakeMessage, 'buffer', {});
                
                if (!buffer) {
                    await bot.sendMessage(chatId, '‚ùå Failed to download sticker.');
                    return;
                }
                
                // Convert WebP to PNG
                const imageBuffer = await sharp(buffer)
                    .png()
                    .toBuffer();
                
                await bot.sendImage(chatId, imageBuffer, 'üñºÔ∏è Sticker converted to image');
                
            } catch (error) {
                await bot.sendMessage(chatId, '‚ùå Error converting sticker to image.');
            }
        }
    },

    url: {  // Alias for tourl, or replace tourl with this
        description: 'Upload image to get URL',
        usage: 'url (reply to image)',
        adminOnly: false,
        execute: async (context) => {
            const { chatId, bot, message } = context;
            
            let targetMessage = null;
            const quotedMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;
            if (quotedMessage?.imageMessage) {
                targetMessage = {
                    key: message.message.extendedTextMessage.contextInfo.stanzaId,
                    message: quotedMessage
                };
            } else if (message.message?.imageMessage) {
                targetMessage = message;
            }
            
            if (!targetMessage) {
                await bot.sendMessage(chatId, '‚ùå Reply to/send an image.');
                return;
            }
            
            try {
                await bot.sendMessage(chatId, '‚è≥ Uploading...');
                const buffer = await downloadMediaMessage(targetMessage, 'buffer', {});
                if (!buffer) return bot.sendMessage(chatId, '‚ùå Download failed.');
                
                // Primary: imgbb
                let imageUrl;
                try {
                    const result = await imgbbUploader({
                        apiKey: 'c7427b69f5258372a34457ff92d7e642',
                        base64string: buffer.toString('base64')
                    });
                    imageUrl = result.display_url;
                } catch (err) {
                    // Fallback: telegra.ph via axios (no extra npm needed)
                    const formData = new FormData();
                    formData.append('file', buffer, 'image.jpg');
                    const res = await axios.post('https://telegra.ph/upload', formData, {
                        headers: formData.getHeaders()
                    });
                    if (res.data && res.data[0] && res.data[0].src) {
                        imageUrl = `https://telegra.ph${res.data[0].src}`;
                    } else {
                        throw new Error('Fallback failed');
                    }
                }
                
                await bot.sendMessage(chatId, `üîó URL: ${imageUrl}`);
            } catch (error) {
                await bot.sendMessage(chatId, '‚ùå Upload failed.');
            }
        }
    },

    lyrics: {
        description: 'Get song lyrics',
        usage: 'lyrics <artist> <song>',
        adminOnly: false,
        execute: async (context) => {
            const { args, chatId, bot } = context;
            if (args.length < 2) return bot.sendMessage(chatId, '‚ùå Provide artist and song.');
            const artist = args[0];
            const title = args.slice(1).join(' ');
            try {
                const lyrics = await lyricsFinder(artist, title);
                if (!lyrics) return bot.sendMessage(chatId, '‚ùå Not found.');
                await bot.sendMessage(chatId, `üéµ ${artist} - ${title}\n\n${lyrics}`);
            } catch (error) {
                await bot.sendMessage(chatId, '‚ùå Fetch failed.');
            }
        }
    },

    series: {
        description: 'Get TV series info',
        usage: 'series <name>',
        adminOnly: false,
        execute: async (context) => {
            const { args, chatId, bot } = context;
            if (!args.length) return bot.sendMessage(chatId, '‚ùå Provide name.');
            const name = args.join(' ');
            try {
                const res = await axios.get(`http://www.omdbapi.com/?t=${encodeURIComponent(name)}&type=series&apikey=4428164a`);
                const data = res.data;
                if (data.Response === 'False') return bot.sendMessage(chatId, '‚ùå Not found.');
                const text = `üì∫ ${data.Title} (${data.Year})\n‚≠ê ${data.imdbRating}/10\nüé≠ ${data.Genre}\nüìù ${data.Plot}\n‚è±Ô∏è ${data.totalSeasons} seasons`;
                await bot.sendMessage(chatId, text);
            } catch (error) {
                await bot.sendMessage(chatId, '‚ùå Fetch failed.');
            }
        }
    },

    sanime: {
        description: 'Search anime details',
        usage: 'sanime <name>',
        adminOnly: false,
        execute: async (context) => {
            const { args, chatId, bot } = context;
            if (!args.length) return bot.sendMessage(chatId, '‚ùå Provide name.');
            const name = args.join(' ');
            try {
                const anime = await anilist.search.anime(name, 1, 1);
                if (!anime.media.length) return bot.sendMessage(chatId, '‚ùå Not found.');
                const id = anime.media[0].id;
                const info = await anilist.media.anime(id);
                const text = `üéå ${info.title.english || info.title.romaji}\n‚≠ê ${info.averageScore}/100\nüì∫ ${info.episodes} eps\nüìÖ ${info.startDate.year}\nüìù ${info.description.slice(0, 300)}...`;
                await bot.sendMessage(chatId, text);
            } catch (error) {
                await bot.sendMessage(chatId, '‚ùå Fetch failed.');
            }
        }
    },

    img: {
        description: 'Search images',
        usage: 'img <query>',
        adminOnly: false,
        execute: async (context) => {
            const { args, chatId, bot } = context;
            if (!args.length) return bot.sendMessage(chatId, '‚ùå Provide query.');
            const query = args.join(' ');
            try {
                const images = await googlethis.image(query, { safe: true });
                if (!images.length) return bot.sendMessage(chatId, '‚ùå No results.');
                const top3 = images.slice(0, 3).map(i => i.url).join('\n');
                await bot.sendMessage(chatId, `üñºÔ∏è Top images for "${query}":\n${top3}`);
            } catch (error) {
                await bot.sendMessage(chatId, '‚ùå Search failed.');
            }
        }
    }
};

module.exports = enhancedCommands;